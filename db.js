// db.js – Lớp tương thích better-sqlite3 nhưng chạy được Postgres (Neon)
const path = require('path');
const fs = require('fs');

const isPg = !!process.env.DATABASE_URL;
let client, pg;

/** Chuyển dấu ? của SQLite -> $1, $2 ... cho Postgres (không dùng regex để tránh lỗi copy/paste) */
function toPgParams(sql, args = []) {
  let i = 0;
  let out = '';
  for (let c of String(sql)) {
    if (c === '?') {
      i += 1;
      out += '$' + i;
    } else {
      out += c;
    }
  }
  return { text: out, values: args };
}


/* ------------------------------------------------------------------ /
/ Postgres (Neon) /
/ ------------------------------------------------------------------ */
async function initPg() {
pg = require('pg');

// Giữ tương thích với PGSSLMODE=require|disable
const wantSSL = (process.env.PGSSLMODE || 'require') !== 'disable';

client = new pg.Pool({
connectionString: process.env.DATABASE_URL,
ssl: wantSSL ? { rejectUnauthorized: false } : false,
max: 5,
});

// 1) Tạo bảng trước (không tạo index ở đây để tránh lỗi khi thiếu cột)
const ddlTables = `
-- ===== tables =====
CREATE TABLE IF NOT EXISTS docs (
id TEXT PRIMARY KEY,
name TEXT,
soHieu TEXT,
loai TEXT,
mucDo TEXT,
donVi TEXT,
hanXuLy TEXT,
nguoiGui TEXT,
nguoiPhuTrach TEXT,
nhan TEXT,
trichYeu TEXT,
uploadedDate TEXT,
webViewLink TEXT,
flow TEXT,
ownerEmail TEXT,
createdAt TIMESTAMP DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS shares (
id SERIAL PRIMARY KEY,
fileId TEXT,
email TEXT,
role TEXT,
notified INTEGER,
message TEXT,
createdAt TIMESTAMP DEFAULT NOW()
);
CREATE UNIQUE INDEX IF NOT EXISTS uq_shares_file_email_role ON shares(fileId, email, role);

CREATE TABLE IF NOT EXISTS members (
id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
hoTen TEXT, tenGoiKhac TEXT, ngaySinh TEXT, gioiTinh TEXT, dienThoai TEXT,
danToc TEXT, tonGiao TEXT, ksTinh TEXT, ksHuyen TEXT, ksXa TEXT,
ngayVaoDang TEXT, ngayChinhThuc TEXT, soTheDang TEXT UNIQUE,
soCCCD TEXT UNIQUE, ngayCapCCCD TEXT,
chiBo TEXT, dangUyCapUy TEXT, donViBoPhan TEXT,
email TEXT,
ngayBatDauSH TEXT, ngayKetThucSH TEXT,
trangThai TEXT, ghiChu TEXT,
createdAt TIMESTAMP DEFAULT NOW()
);
CREATE UNIQUE INDEX IF NOT EXISTS uq_members_email ON members(email);

CREATE TABLE IF NOT EXISTS users (
id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
email TEXT UNIQUE,
fullName TEXT,
partyId TEXT,
role TEXT DEFAULT 'user',
scopes TEXT,
manageAll INTEGER DEFAULT 0,
manageUnits TEXT,
manageChiBo TEXT,
userUnit TEXT,
userChiBo TEXT,
chibo TEXT,
hash TEXT,
active INTEGER DEFAULT 1,
googleEmail TEXT,
createdAt TIMESTAMP DEFAULT NOW()
);
`;
await exec(ddlTables);

// 2) Migration an toàn – đảm bảo cột tồn tại TRƯỚC khi tạo index
await exec(`
-- Thêm cột chibo nếu thiếu (users, members)
ALTER TABLE users ADD COLUMN IF NOT EXISTS chibo TEXT;
ALTER TABLE members ADD COLUMN IF NOT EXISTS chibo TEXT;

-- Xóa index cũ sai tên cột nếu từng tồn tại (nguoi -> không có cột này)
DROP INDEX IF EXISTS idx_docs_nguoi;


`);

// 3) Tạo index (chỉ tạo idx_members_chiBo khi cột đã có)
const ddlIndexes = `
CREATE INDEX IF NOT EXISTS idx_docs_createdAt ON docs(createdAt);
CREATE INDEX IF NOT EXISTS idx_docs_flow ON docs(flow);
CREATE INDEX IF NOT EXISTS idx_docs_donVi ON docs(donVi);
CREATE INDEX IF NOT EXISTS idx_docs_mucDo ON docs(mucDo);
CREATE INDEX IF NOT EXISTS idx_docs_loai ON docs(loai);
CREATE INDEX IF NOT EXISTS idx_docs_soHieu ON docs(soHieu);
CREATE INDEX IF NOT EXISTS idx_docs_nguoiGui ON docs(nguoiGui);
CREATE INDEX IF NOT EXISTS idx_docs_nguoiPT ON docs(nguoiPhuTrach);
CREATE INDEX IF NOT EXISTS idx_docs_hanXuLy ON docs(hanXuLy);
CREATE INDEX IF NOT EXISTS idx_docs_ownerEmail ON docs(ownerEmail);

CREATE INDEX IF NOT EXISTS idx_shares_file      ON shares(fileId);
CREATE INDEX IF NOT EXISTS idx_shares_email     ON shares(email);

CREATE INDEX IF NOT EXISTS idx_members_email    ON members(email);

DO $$
BEGIN
  IF EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_name='members' AND column_name='chibo'
  ) THEN
    CREATE INDEX IF NOT EXISTS idx_members_chiBo ON members(chibo);
  END IF;
END$$;

CREATE INDEX IF NOT EXISTS idx_members_created  ON members(createdAt);

CREATE INDEX IF NOT EXISTS idx_users_role        ON users(role);
CREATE INDEX IF NOT EXISTS idx_users_googleEmail ON users(googleemail);


`;
await exec(ddlIndexes);
}

/* ---------------- API dùng chung cho Postgres -------------------- */
async function query(sql, ...args) {
const { text, values } = toPgParams(sql, args);
const r = await client.query(text, values);
return r;
}
async function get(sql, ...args) {
const r = await query(sql, ...args);
return r.rows[0] || undefined;
}
async function all(sql, ...args) {
const r = await query(sql, ...args);
return r.rows;
}
async function run(sql, ...args) {
await query(sql, ...args);
return { changes: 1 };
}
async function exec(multiSql) {
const conn = await client.connect();
try {
await conn.query('BEGIN');
await conn.query(multiSql);
await conn.query('COMMIT');
} catch (e) {
await conn.query('ROLLBACK');
throw e;
} finally {
conn.release();
}
}
function prepare(sql) {
return {
get: (...args) => get(sql, ...args),
all: (...args) => all(sql, ...args),
run: (...args) => run(sql, ...args),
};
}
function transaction(fn) {
return async function () {
const conn = await client.connect();
try {
await conn.query('BEGIN');
const txApi = {
get: async (s, ...a) => {
const { text, values } = toPgParams(s, a);
return (await conn.query(text, values)).rows[0];
},
all: async (s, ...a) => {
const { text, values } = toPgParams(s, a);
return (await conn.query(text, values)).rows;
},
run: async (s, ...a) => {
const { text, values } = toPgParams(s, a);
await conn.query(text, values);
return { changes: 1 };
},
prepare: (s) => ({
get: (...a) => txApi.get(s, ...a),
all: (...a) => txApi.all(s, ...a),
run: (...a) => txApi.run(s, ...a),
}),
};
await fn(txApi);
await conn.query('COMMIT');
} catch (e) {
await conn.query('ROLLBACK');
throw e;
} finally {
conn.release();
}
};
}

/* ------------------------------------------------------------------ /
/ SQLite (fallback dev) /
/ ------------------------------------------------------------------ */
let sqliteDb;
function initSqlite() {
const Database = require('better-sqlite3');
const DB_PATH = process.env.DB_PATH || path.join(__dirname, 'data', 'party.sqlite');
fs.mkdirSync(path.dirname(DB_PATH), { recursive: true });
sqliteDb = new Database(DB_PATH);
sqliteDb.pragma('busy_timeout = 3000');
sqliteDb.pragma('synchronous = NORMAL');

// DDL giống server.js
sqliteDb.exec(`
PRAGMA journal_mode = WAL;

CREATE TABLE IF NOT EXISTS docs (
  id TEXT PRIMARY KEY,
  name TEXT, soHieu TEXT, loai TEXT, mucDo TEXT, donVi TEXT,
  hanXuLy TEXT, nguoiGui TEXT, nguoiPhuTrach TEXT, nhan TEXT, trichYeu TEXT,
  uploadedDate TEXT, webViewLink TEXT, flow TEXT, ownerEmail TEXT,
  createdAt TEXT DEFAULT (datetime('now'))
);

CREATE TABLE IF NOT EXISTS shares (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  fileId TEXT, email TEXT, role TEXT, notified INTEGER, message TEXT,
  createdAt TEXT DEFAULT (datetime('now'))
);

CREATE TABLE IF NOT EXISTS members (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  hoTen TEXT, tenGoiKhac TEXT, ngaySinh TEXT, gioiTinh TEXT, dienThoai TEXT,
  danToc TEXT, tonGiao TEXT, ksTinh TEXT, ksHuyen TEXT, ksXa TEXT,
  ngayVaoDang TEXT, ngayChinhThuc TEXT, soTheDang TEXT UNIQUE,
  soCCCD TEXT UNIQUE, ngayCapCCCD TEXT, chiBo TEXT, dangUyCapUy TEXT,
  donViBoPhan TEXT, email TEXT,
  ngayBatDauSH TEXT, ngayKetThucSH TEXT,
  trangThai TEXT, ghiChu TEXT,
  createdAt TEXT DEFAULT (datetime('now'))
);

CREATE TABLE IF NOT EXISTS users (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  email TEXT UNIQUE, fullName TEXT, partyId TEXT, role TEXT DEFAULT 'user',
  scopes TEXT, manageAll INTEGER DEFAULT 0, manageUnits TEXT, manageChiBo TEXT,
  userUnit TEXT, userChiBo TEXT, chibo TEXT,
  hash TEXT, active INTEGER DEFAULT 1,
  googleEmail TEXT, createdAt TEXT DEFAULT (datetime('now'))
);

CREATE UNIQUE INDEX IF NOT EXISTS uq_shares_file_email_role ON shares(fileId, email, role);
CREATE UNIQUE INDEX IF NOT EXISTS uq_members_email ON members(email);

CREATE INDEX IF NOT EXISTS idx_docs_createdAt   ON docs(createdAt);
CREATE INDEX IF NOT EXISTS idx_docs_flow        ON docs(flow);
CREATE INDEX IF NOT EXISTS idx_docs_donVi       ON docs(donVi);
CREATE INDEX IF NOT EXISTS idx_docs_mucDo       ON docs(mucDo);
CREATE INDEX IF NOT EXISTS idx_docs_loai        ON docs(loai);
CREATE INDEX IF NOT EXISTS idx_docs_soHieu      ON docs(soHieu);
CREATE INDEX IF NOT EXISTS idx_docs_nguoiGui    ON docs(nguoiGui);
CREATE INDEX IF NOT EXISTS idx_docs_nguoiPT     ON docs(nguoiPhuTrach);
CREATE INDEX IF NOT EXISTS idx_docs_hanXuLy     ON docs(hanXuLy);
CREATE INDEX IF NOT EXISTS idx_docs_ownerEmail  ON docs(ownerEmail);

CREATE INDEX IF NOT EXISTS idx_shares_file      ON shares(fileId);
CREATE INDEX IF NOT EXISTS idx_shares_email     ON shares(email);

CREATE INDEX IF NOT EXISTS idx_members_email    ON members(email);
CREATE INDEX IF NOT EXISTS idx_members_chiBo    ON members(chiBo);
CREATE INDEX IF NOT EXISTS idx_members_created  ON members(createdAt);
CREATE INDEX IF NOT EXISTS idx_users_role       ON users(role);
CREATE INDEX IF NOT EXISTS idx_users_googleEmail ON users(googleEmail);


`);
}

function wrapSqlite() {
return {
get: (s, ...a) => sqliteDb.prepare(s).get(...a),
all: (s, ...a) => sqliteDb.prepare(s).all(...a),
run: (s, ...a) => sqliteDb.prepare(s).run(...a),
exec: (s) => sqliteDb.exec(s),
prepare: (s) => sqliteDb.prepare(s),
transaction: (fn) => () => {
const tx = sqliteDb.transaction(() => fn(module.exports));
tx();
},
};
}

/* ------------------------------------------------------------------ */
let api = null;
async function init() {
if (isPg) {
await initPg();
api = { get, all, run, exec, prepare, transaction };
} else {
initSqlite();
api = wrapSqlite();
}
}
const ready = init();

module.exports = new Proxy(
{},
{
get(_, prop) {
if (prop === 'isPg') return isPg;
if (prop === 'ready') return ready;
return (...args) => apiprop
;
},
}
);

